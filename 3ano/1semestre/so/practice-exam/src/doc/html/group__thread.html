<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ Library, mos@ua: thread</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C++ Library, mos@ua
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">cpplib-mos</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__thread.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">thread</div>  </div>
</div><!--header-->
<div class="contents">

<p>POSIX threads library wrapper module.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:thread_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html">thread.h</a></td></tr>
<tr class="memdesc:thread_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">POSIX threads library wrapper module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Thread handling</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbb23b9d789e57cecf4e2351b19a64b31"></a>Variable type: <code>pthread_t</code></p>
<p><a class="anchor" id="thread"></a></p>
</td></tr>
<tr class="memitem:gadca8bdcec91b8985370d904591d342b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#gadca8bdcec91b8985370d904591d342b8">thread_equal</a> (pthread_t t1, pthread_t t2)</td></tr>
<tr class="memdesc:gadca8bdcec91b8985370d904591d342b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_equal</code> wrapper function.  <a href="group__thread.html#gadca8bdcec91b8985370d904591d342b8">More...</a><br /></td></tr>
<tr class="separator:gadca8bdcec91b8985370d904591d342b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a0f9920a321b54c41c098d3461d3889"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga3a0f9920a321b54c41c098d3461d3889">thread_create</a> (pthread_t *t, pthread_attr_t *attr, void *(*thread_main)(void *), void *arg)</td></tr>
<tr class="memdesc:ga3a0f9920a321b54c41c098d3461d3889"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_create</code> wrapper function.  <a href="group__thread.html#ga3a0f9920a321b54c41c098d3461d3889">More...</a><br /></td></tr>
<tr class="separator:ga3a0f9920a321b54c41c098d3461d3889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606fdef53f997c231e0e1e9e54b350d4"><td class="memItemLeft" align="right" valign="top">pthread_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga606fdef53f997c231e0e1e9e54b350d4">thread_self</a> ()</td></tr>
<tr class="memdesc:ga606fdef53f997c231e0e1e9e54b350d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_self</code> wrapper function.  <a href="group__thread.html#ga606fdef53f997c231e0e1e9e54b350d4">More...</a><br /></td></tr>
<tr class="separator:ga606fdef53f997c231e0e1e9e54b350d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga952c63101c667d247f0923b609710c72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga952c63101c667d247f0923b609710c72">thread_sched_yield</a> (void)</td></tr>
<tr class="memdesc:ga952c63101c667d247f0923b609710c72"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>sched_yield</code> wrapper function.  <a href="group__thread.html#ga952c63101c667d247f0923b609710c72">More...</a><br /></td></tr>
<tr class="separator:ga952c63101c667d247f0923b609710c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19b16adf05364471bae2840aa564329a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga19b16adf05364471bae2840aa564329a">thread_exit</a> (void *retval)</td></tr>
<tr class="memdesc:ga19b16adf05364471bae2840aa564329a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_exit</code> wrapper function.  <a href="group__thread.html#ga19b16adf05364471bae2840aa564329a">More...</a><br /></td></tr>
<tr class="separator:ga19b16adf05364471bae2840aa564329a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86aa7989874009c886bea9d41700e25c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga86aa7989874009c886bea9d41700e25c">thread_detach</a> (pthread_t thread)</td></tr>
<tr class="memdesc:ga86aa7989874009c886bea9d41700e25c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_detach</code> wrapper function.  <a href="group__thread.html#ga86aa7989874009c886bea9d41700e25c">More...</a><br /></td></tr>
<tr class="separator:ga86aa7989874009c886bea9d41700e25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b2370a45c1518f777493526b2e4f46d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga2b2370a45c1518f777493526b2e4f46d">thread_join</a> (pthread_t t, void **result)</td></tr>
<tr class="memdesc:ga2b2370a45c1518f777493526b2e4f46d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_join</code> wrapper function.  <a href="group__thread.html#ga2b2370a45c1518f777493526b2e4f46d">More...</a><br /></td></tr>
<tr class="separator:ga2b2370a45c1518f777493526b2e4f46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mutexes</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp36ad3aaeba2e57a68bfc89685b71cb73"></a>Variable type: <code>pthread_mutex_t</code></p>
<p>Initialization of mutexes can be static or dynamic.</p>
<p>In static initialization the following initialization macros are suggested:</p><ul>
<li><code>PTHREAD_MUTEX_INITIALIZER</code> - standard initializer</li>
<li><code>PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP</code> - initializer that ensures error checking</li>
<li><code>PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP</code> - for recursive mutexes (note that recursive mutexes should be avoid)</li>
</ul>
<p>Dynamic initialization is done by <a class="el" href="group__thread.html#ga3f227a19d6a339ce0aeda15775e5e6e6" title="pthread_mutex_init wrapper function.">mutex_init()</a> and <a class="el" href="group__thread.html#ga5ebb836d0f83eac719f2cdd336497b01" title="pthread_mutex_destroy wrapper function.">mutex_destroy()</a>.</p>
<p><a class="anchor" id="mutex"></a></p>
</td></tr>
<tr class="memitem:ga3f227a19d6a339ce0aeda15775e5e6e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga3f227a19d6a339ce0aeda15775e5e6e6">mutex_init</a> (pthread_mutex_t *pmtx, pthread_mutexattr_t *attr)</td></tr>
<tr class="memdesc:ga3f227a19d6a339ce0aeda15775e5e6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_mutex_init</code> wrapper function.  <a href="group__thread.html#ga3f227a19d6a339ce0aeda15775e5e6e6">More...</a><br /></td></tr>
<tr class="separator:ga3f227a19d6a339ce0aeda15775e5e6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ebb836d0f83eac719f2cdd336497b01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga5ebb836d0f83eac719f2cdd336497b01">mutex_destroy</a> (pthread_mutex_t *pmtx)</td></tr>
<tr class="memdesc:ga5ebb836d0f83eac719f2cdd336497b01"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_mutex_destroy</code> wrapper function.  <a href="group__thread.html#ga5ebb836d0f83eac719f2cdd336497b01">More...</a><br /></td></tr>
<tr class="separator:ga5ebb836d0f83eac719f2cdd336497b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87086ba0f13f6ddc479a6bc803a10c39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga87086ba0f13f6ddc479a6bc803a10c39">mutex_lock</a> (pthread_mutex_t *pmtx)</td></tr>
<tr class="memdesc:ga87086ba0f13f6ddc479a6bc803a10c39"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_mutex_lock</code> wrapper function.  <a href="group__thread.html#ga87086ba0f13f6ddc479a6bc803a10c39">More...</a><br /></td></tr>
<tr class="separator:ga87086ba0f13f6ddc479a6bc803a10c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bd074884e1c92e88ca8ea0552d9a928"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga8bd074884e1c92e88ca8ea0552d9a928">mutex_trylock</a> (pthread_mutex_t *pmtx)</td></tr>
<tr class="memdesc:ga8bd074884e1c92e88ca8ea0552d9a928"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_mutex_trylock</code> wrapper function.  <a href="group__thread.html#ga8bd074884e1c92e88ca8ea0552d9a928">More...</a><br /></td></tr>
<tr class="separator:ga8bd074884e1c92e88ca8ea0552d9a928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95235231165ebda870afa10ba5fd6c41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga95235231165ebda870afa10ba5fd6c41">mutex_unlock</a> (pthread_mutex_t *pmtx)</td></tr>
<tr class="memdesc:ga95235231165ebda870afa10ba5fd6c41"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_mutex_unlock</code> wrapper function.  <a href="group__thread.html#ga95235231165ebda870afa10ba5fd6c41">More...</a><br /></td></tr>
<tr class="separator:ga95235231165ebda870afa10ba5fd6c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Condition variables</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5d27ca402fc9b8d5029222edb6f36304"></a>Variable type: <code>pthread_cond_t</code></p>
<p>Initialization of condition variables can be static or dynamic.</p>
<p>In static initialization the following initialization macros should be used:</p><ul>
<li><code>PTHREAD_COND_INITIALIZER</code> - standard initializer</li>
</ul>
<p>Dynamic initialization is done by <a class="el" href="group__thread.html#ga31e5eaf158d118d0e4ef7fd47368eaad" title="pthread_cond_init wrapper function.">cond_init()</a> and <a class="el" href="group__thread.html#gad663c43fbfbb4f660d48b07e110c8f80" title="pthread_cond_destroy wrapper function.">cond_destroy()</a>.</p>
<p><a class="anchor" id="cvar"></a></p>
</td></tr>
<tr class="memitem:ga31e5eaf158d118d0e4ef7fd47368eaad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga31e5eaf158d118d0e4ef7fd47368eaad">cond_init</a> (pthread_cond_t *pcvar, pthread_condattr_t *attr)</td></tr>
<tr class="memdesc:ga31e5eaf158d118d0e4ef7fd47368eaad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_cond_init</code> wrapper function.  <a href="group__thread.html#ga31e5eaf158d118d0e4ef7fd47368eaad">More...</a><br /></td></tr>
<tr class="separator:ga31e5eaf158d118d0e4ef7fd47368eaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad663c43fbfbb4f660d48b07e110c8f80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#gad663c43fbfbb4f660d48b07e110c8f80">cond_destroy</a> (pthread_cond_t *pcvar)</td></tr>
<tr class="memdesc:gad663c43fbfbb4f660d48b07e110c8f80"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_cond_destroy</code> wrapper function.  <a href="group__thread.html#gad663c43fbfbb4f660d48b07e110c8f80">More...</a><br /></td></tr>
<tr class="separator:gad663c43fbfbb4f660d48b07e110c8f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1123643838d5174ccd41f52f4169e896"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga1123643838d5174ccd41f52f4169e896">cond_wait</a> (pthread_cond_t *pcvar, pthread_mutex_t *pmtx)</td></tr>
<tr class="memdesc:ga1123643838d5174ccd41f52f4169e896"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_cond_wait</code> wrapper function.  <a href="group__thread.html#ga1123643838d5174ccd41f52f4169e896">More...</a><br /></td></tr>
<tr class="separator:ga1123643838d5174ccd41f52f4169e896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cd2040836c30e4f0ea17abe4f66b8e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga8cd2040836c30e4f0ea17abe4f66b8e2">cond_timedwait</a> (pthread_cond_t *pcvar, pthread_mutex_t *pmtx, const struct timespec *abstime)</td></tr>
<tr class="memdesc:ga8cd2040836c30e4f0ea17abe4f66b8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_cond_timedwait</code> wrapper function.  <a href="group__thread.html#ga8cd2040836c30e4f0ea17abe4f66b8e2">More...</a><br /></td></tr>
<tr class="separator:ga8cd2040836c30e4f0ea17abe4f66b8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b41089ba3cd8ad0a539b42bc8b95d6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga4b41089ba3cd8ad0a539b42bc8b95d6b">cond_timedwait</a> (pthread_cond_t *pcvar, pthread_mutex_t *pmtx, long relative_time_us)</td></tr>
<tr class="memdesc:ga4b41089ba3cd8ad0a539b42bc8b95d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_cond_timedwait</code> wrapper function accepting relative time (in microseconds) instead of absolute time.  <a href="group__thread.html#ga4b41089ba3cd8ad0a539b42bc8b95d6b">More...</a><br /></td></tr>
<tr class="separator:ga4b41089ba3cd8ad0a539b42bc8b95d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9624688b577fb653af7a528848cc53d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga9624688b577fb653af7a528848cc53d5">cond_signal</a> (pthread_cond_t *pcvar)</td></tr>
<tr class="memdesc:ga9624688b577fb653af7a528848cc53d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_cond_signal</code> wrapper function.  <a href="group__thread.html#ga9624688b577fb653af7a528848cc53d5">More...</a><br /></td></tr>
<tr class="separator:ga9624688b577fb653af7a528848cc53d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6459039ab27da7237dda2bbc866eb2d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga6459039ab27da7237dda2bbc866eb2d0">cond_broadcast</a> (pthread_cond_t *pcvar)</td></tr>
<tr class="memdesc:ga6459039ab27da7237dda2bbc866eb2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_cond_broadcast</code> wrapper function.  <a href="group__thread.html#ga6459039ab27da7237dda2bbc866eb2d0">More...</a><br /></td></tr>
<tr class="separator:ga6459039ab27da7237dda2bbc866eb2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
One-time initialization</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp58bc8e91d218a3f6ce7adfa06d39e510"></a>Variable type: <code>pthread_once_t</code></p>
<p>POSIX thread library support a mechanism that ensures a one-time execution of a function. It does it through <code>pthread_once_t</code> variables, and by passing a callback function (in C/C++ is simply a function pointer).</p>
<dl class="section user"><dt>Example</dt><dd><pre class="fragment">   void once_init_routine(void) { ... }
   ...
   pthread_once_t once_control = PTHREAD_ONCE_INIT;
   thread_once(&amp;once_control, &amp;once_init_routine); // one time execution over pthread_once_t
                                                   // variable is guaranteed, regardless of the
                                                   // number of threads that execute over that
                                                   // variable.
</pre></dd></dl>
<p><a class="anchor" id="thread_once"></a></p>
</td></tr>
<tr class="memitem:gad0428e8a0809704f4b3d682f26d3ef1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#gad0428e8a0809704f4b3d682f26d3ef1c">thread_once</a> (pthread_once_t *once_control, void(*init_routine)(void))</td></tr>
<tr class="memdesc:gad0428e8a0809704f4b3d682f26d3ef1c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_once</code> wrapper function.  <a href="group__thread.html#gad0428e8a0809704f4b3d682f26d3ef1c">More...</a><br /></td></tr>
<tr class="separator:gad0428e8a0809704f4b3d682f26d3ef1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Thread-specific data</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp83c2491ff56c7716ea8ad0d77487d1ef"></a>Variable type: <code>pthread_key_t</code></p>
<p>Thread-specific data allows the definition of variable whose scope is limited to each thread. In practice, we will have a common variable, with a common access, but with different values for each thread.</p>
<p><a class="anchor" id="thread_specific"></a></p>
</td></tr>
<tr class="memitem:ga7df1983f57dca40a86a55d215d13d42b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga7df1983f57dca40a86a55d215d13d42b">thread_key_create</a> (pthread_key_t *key, void(*destr_function)(void *))</td></tr>
<tr class="memdesc:ga7df1983f57dca40a86a55d215d13d42b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_key_create</code> wrapper function.  <a href="group__thread.html#ga7df1983f57dca40a86a55d215d13d42b">More...</a><br /></td></tr>
<tr class="separator:ga7df1983f57dca40a86a55d215d13d42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a50dfc97c087a28cb916e0f30f760e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga65a50dfc97c087a28cb916e0f30f760e">thread_key_delete</a> (pthread_key_t key)</td></tr>
<tr class="memdesc:ga65a50dfc97c087a28cb916e0f30f760e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_key_delete</code> wrapper function.  <a href="group__thread.html#ga65a50dfc97c087a28cb916e0f30f760e">More...</a><br /></td></tr>
<tr class="separator:ga65a50dfc97c087a28cb916e0f30f760e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3008b033f2830e79179a882a2b74c8ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga3008b033f2830e79179a882a2b74c8ba">thread_setspecific</a> (pthread_key_t key, void *pointer)</td></tr>
<tr class="memdesc:ga3008b033f2830e79179a882a2b74c8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_setspecific</code> wrapper function.  <a href="group__thread.html#ga3008b033f2830e79179a882a2b74c8ba">More...</a><br /></td></tr>
<tr class="separator:ga3008b033f2830e79179a882a2b74c8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d207f1bb2e1d493b68a026b8650cb16"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga0d207f1bb2e1d493b68a026b8650cb16">thread_getspecific</a> (pthread_key_t key)</td></tr>
<tr class="memdesc:ga0d207f1bb2e1d493b68a026b8650cb16"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_getspecific</code> wrapper function.  <a href="group__thread.html#ga0d207f1bb2e1d493b68a026b8650cb16">More...</a><br /></td></tr>
<tr class="separator:ga0d207f1bb2e1d493b68a026b8650cb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mutex attributes</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb36cf7fa61aca4b51ec2b1467dc38b7d"></a>Variable type: <code>pthread_mutexattr_t</code></p>
<p><a class="anchor" id="mutex_attr"></a></p>
</td></tr>
<tr class="memitem:ga9fb2733a01e8d668a2022005ea5dbebd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga9fb2733a01e8d668a2022005ea5dbebd">mutexattr_init</a> (pthread_mutexattr_t *attr)</td></tr>
<tr class="memdesc:ga9fb2733a01e8d668a2022005ea5dbebd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_mutexattr_init</code> wrapper function.  <a href="group__thread.html#ga9fb2733a01e8d668a2022005ea5dbebd">More...</a><br /></td></tr>
<tr class="separator:ga9fb2733a01e8d668a2022005ea5dbebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07bf0e49b1f2cb99d3a2955641c676d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga07bf0e49b1f2cb99d3a2955641c676d5">mutexattr_destroy</a> (pthread_mutexattr_t *attr)</td></tr>
<tr class="memdesc:ga07bf0e49b1f2cb99d3a2955641c676d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_mutexattr_destroy</code> wrapper function.  <a href="group__thread.html#ga07bf0e49b1f2cb99d3a2955641c676d5">More...</a><br /></td></tr>
<tr class="separator:ga07bf0e49b1f2cb99d3a2955641c676d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga601a6a9527d7d5ee2ca2870cddc4afc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga601a6a9527d7d5ee2ca2870cddc4afc2">mutexattr_settype</a> (pthread_mutexattr_t *attr, int type)</td></tr>
<tr class="memdesc:ga601a6a9527d7d5ee2ca2870cddc4afc2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_mutexattr_settype</code> wrapper function.  <a href="group__thread.html#ga601a6a9527d7d5ee2ca2870cddc4afc2">More...</a><br /></td></tr>
<tr class="separator:ga601a6a9527d7d5ee2ca2870cddc4afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf741e1818d53c5b7d71cd68e161b215"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#gadf741e1818d53c5b7d71cd68e161b215">mutexattr_gettype</a> (const pthread_mutexattr_t *attr, int *kind)</td></tr>
<tr class="memdesc:gadf741e1818d53c5b7d71cd68e161b215"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_mutexattr_gettype</code> wrapper function.  <a href="group__thread.html#gadf741e1818d53c5b7d71cd68e161b215">More...</a><br /></td></tr>
<tr class="separator:gadf741e1818d53c5b7d71cd68e161b215"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Condition variables attributes</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp27baaadc2d0c71b075af028f283eacd7"></a>Variable type: <code>pthread_condattr_t</code></p>
<p><a class="anchor" id="cond_attr"></a></p>
</td></tr>
<tr class="memitem:gab8073c72be896ba9d711d887a5405a74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#gab8073c72be896ba9d711d887a5405a74">condattr_init</a> (pthread_condattr_t *attr)</td></tr>
<tr class="memdesc:gab8073c72be896ba9d711d887a5405a74"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_condattr_init</code> wrapper function.  <a href="group__thread.html#gab8073c72be896ba9d711d887a5405a74">More...</a><br /></td></tr>
<tr class="separator:gab8073c72be896ba9d711d887a5405a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4644f4989b30ccfb2e908017c43bd0d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga4644f4989b30ccfb2e908017c43bd0d0">condattr_destroy</a> (pthread_condattr_t *attr)</td></tr>
<tr class="memdesc:ga4644f4989b30ccfb2e908017c43bd0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_condattr_destroy</code> wrapper function.  <a href="group__thread.html#ga4644f4989b30ccfb2e908017c43bd0d0">More...</a><br /></td></tr>
<tr class="separator:ga4644f4989b30ccfb2e908017c43bd0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Thread attributes</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5f5f98f9c3263331bbb4930904f08778"></a>Variable type: <code>pthread_attr_t</code></p>
<p><a class="anchor" id="thread_attr"></a></p>
</td></tr>
<tr class="memitem:gaaf2db7012069f0006e7ffaf257d8ccc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#gaaf2db7012069f0006e7ffaf257d8ccc6">thread_attr_init</a> (pthread_attr_t *attr)</td></tr>
<tr class="memdesc:gaaf2db7012069f0006e7ffaf257d8ccc6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_attr_init</code> wrapper function.  <a href="group__thread.html#gaaf2db7012069f0006e7ffaf257d8ccc6">More...</a><br /></td></tr>
<tr class="separator:gaaf2db7012069f0006e7ffaf257d8ccc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a9c2c051deee01e21c75f0fa8b2e9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#gaf3a9c2c051deee01e21c75f0fa8b2e9c">thread_attr_destroy</a> (pthread_attr_t *attr)</td></tr>
<tr class="memdesc:gaf3a9c2c051deee01e21c75f0fa8b2e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_attr_destroy</code> wrapper function.  <a href="group__thread.html#gaf3a9c2c051deee01e21c75f0fa8b2e9c">More...</a><br /></td></tr>
<tr class="separator:gaf3a9c2c051deee01e21c75f0fa8b2e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc82fea1785fc82aeb2f43cdd77b9b0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#gabc82fea1785fc82aeb2f43cdd77b9b0f">thread_attr_setdetachstate</a> (pthread_attr_t *attr, int detachstate)</td></tr>
<tr class="memdesc:gabc82fea1785fc82aeb2f43cdd77b9b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_attr_setdetachstate</code> wrapper function.  <a href="group__thread.html#gabc82fea1785fc82aeb2f43cdd77b9b0f">More...</a><br /></td></tr>
<tr class="separator:gabc82fea1785fc82aeb2f43cdd77b9b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae83c8617612c1bb481fec2b382ac9c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#gaae83c8617612c1bb481fec2b382ac9c4">thread_attr_getdetachstate</a> (const pthread_attr_t *attr, int *pdetachstate)</td></tr>
<tr class="memdesc:gaae83c8617612c1bb481fec2b382ac9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_attr_getdetachstate</code> wrapper function.  <a href="group__thread.html#gaae83c8617612c1bb481fec2b382ac9c4">More...</a><br /></td></tr>
<tr class="separator:gaae83c8617612c1bb481fec2b382ac9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cancellation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp3ae3f4b3ded0b8210c884979e229f062"></a><a class="anchor" id="thread_cancellation"></a></p>
</td></tr>
<tr class="memitem:ga1b3cb53565eabe02a36e000e5244dfd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga1b3cb53565eabe02a36e000e5244dfd1">thread_cancel</a> (pthread_t thread)</td></tr>
<tr class="memdesc:ga1b3cb53565eabe02a36e000e5244dfd1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_cancel</code> wrapper function.  <a href="group__thread.html#ga1b3cb53565eabe02a36e000e5244dfd1">More...</a><br /></td></tr>
<tr class="separator:ga1b3cb53565eabe02a36e000e5244dfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98baffe08beec792f3428ae9ddad966e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga98baffe08beec792f3428ae9ddad966e">thread_setcancelstate</a> (int state, int *oldstate)</td></tr>
<tr class="memdesc:ga98baffe08beec792f3428ae9ddad966e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_setcancelstate</code> wrapper function.  <a href="group__thread.html#ga98baffe08beec792f3428ae9ddad966e">More...</a><br /></td></tr>
<tr class="separator:ga98baffe08beec792f3428ae9ddad966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4ec114c7b59f8f4185bac648b256d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#gab4ec114c7b59f8f4185bac648b256d0c">thread_setcanceltype</a> (int type, int *oldtype)</td></tr>
<tr class="memdesc:gab4ec114c7b59f8f4185bac648b256d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_setcanceltype</code> wrapper function.  <a href="group__thread.html#gab4ec114c7b59f8f4185bac648b256d0c">More...</a><br /></td></tr>
<tr class="separator:gab4ec114c7b59f8f4185bac648b256d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81bdb13d62e16ad7cb3cbd263c9a5671"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread.html#ga81bdb13d62e16ad7cb3cbd263c9a5671">thread_testcancel</a> (void)</td></tr>
<tr class="memdesc:ga81bdb13d62e16ad7cb3cbd263c9a5671"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pthread_testcancel</code> wrapper function.  <a href="group__thread.html#ga81bdb13d62e16ad7cb3cbd263c9a5671">More...</a><br /></td></tr>
<tr class="separator:ga81bdb13d62e16ad7cb3cbd263c9a5671"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>POSIX threads library wrapper module. </p>
<p>This module removes defensive programming approach of native POSIX threads library.</p>
<p>All implemented functions, have exactly the same arguments and/or result of the original function, with the exception of returning an error indication.</p>
<p>Errors are handled by the implementation of two policies:</p><ol type="1">
<li>EXIT_POLICY (default): describes the failed call in <code>stderr</code> (with the identification of the errno error, and the precise location the call), generates a segmentation fault (enabling a stack trace within a debugger like <code>gdb</code>), and exits program execution;</li>
<li>EXCEPTION_POLICY: throws a <code>int</code> exception with the (errno) status error returned by the original function.</li>
</ol>
<dl class="section author"><dt>Author</dt><dd>Miguel Oliveira e Silva, 2017-2018 </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gadca8bdcec91b8985370d904591d342b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadca8bdcec91b8985370d904591d342b8">&#9670;&nbsp;</a></span>thread_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_equal </td>
          <td>(</td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_equal</code> wrapper function. </p>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_equal </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_equal(3)">https://man.cx/pthread_equal(3)</a> </dd></dl>

</div>
</div>
<a id="ga3a0f9920a321b54c41c098d3461d3889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a0f9920a321b54c41c098d3461d3889">&#9670;&nbsp;</a></span>thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_create </td>
          <td>(</td>
          <td class="paramtype">pthread_t *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_attr_t *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>thread_main</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_create</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>t != NULL</code><br  />
 <code>thread_main != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_create </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_create(3)">https://man.cx/pthread_create(3)</a> </dd></dl>

</div>
</div>
<a id="ga606fdef53f997c231e0e1e9e54b350d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga606fdef53f997c231e0e1e9e54b350d4">&#9670;&nbsp;</a></span>thread_self()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_t thread_self </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_self</code> wrapper function. </p>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_self </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_self(3)">https://man.cx/pthread_self(3)</a> </dd></dl>

</div>
</div>
<a id="ga952c63101c667d247f0923b609710c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga952c63101c667d247f0923b609710c72">&#9670;&nbsp;</a></span>thread_sched_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_sched_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>sched_yield</code> wrapper function. </p>
<p>Other documentation in</p><pre class="fragment">man 3 sched_yield </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/sched_yield(3)">https://man.cx/sched_yield(3)</a> </dd></dl>

</div>
</div>
<a id="ga19b16adf05364471bae2840aa564329a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19b16adf05364471bae2840aa564329a">&#9670;&nbsp;</a></span>thread_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_exit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>retval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_exit</code> wrapper function. </p>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_exit </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_exit(3)">https://man.cx/pthread_exit(3)</a> </dd></dl>

</div>
</div>
<a id="ga86aa7989874009c886bea9d41700e25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86aa7989874009c886bea9d41700e25c">&#9670;&nbsp;</a></span>thread_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_detach </td>
          <td>(</td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_detach</code> wrapper function. </p>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_detach </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_detach(3)">https://man.cx/pthread_detach(3)</a> </dd></dl>

</div>
</div>
<a id="ga2b2370a45c1518f777493526b2e4f46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b2370a45c1518f777493526b2e4f46d">&#9670;&nbsp;</a></span>thread_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_join </td>
          <td>(</td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_join</code> wrapper function. </p>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_join </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_join(3)">https://man.cx/pthread_join(3)</a> </dd></dl>

</div>
</div>
<a id="ga3f227a19d6a339ce0aeda15775e5e6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f227a19d6a339ce0aeda15775e5e6e6">&#9670;&nbsp;</a></span>mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutex_init </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>pmtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_mutexattr_t *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_mutex_init</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>pmtx != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_mutex_init </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_mutex_init(3)">https://man.cx/pthread_mutex_init(3)</a> </dd></dl>

</div>
</div>
<a id="ga5ebb836d0f83eac719f2cdd336497b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ebb836d0f83eac719f2cdd336497b01">&#9670;&nbsp;</a></span>mutex_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutex_destroy </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>pmtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_mutex_destroy</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>pmtx != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_mutex_destroy </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_mutex_destroy(3)">https://man.cx/pthread_mutex_destroy(3)</a> </dd></dl>

</div>
</div>
<a id="ga87086ba0f13f6ddc479a6bc803a10c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87086ba0f13f6ddc479a6bc803a10c39">&#9670;&nbsp;</a></span>mutex_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutex_lock </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>pmtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_mutex_lock</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>pmtx != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_mutex_lock </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_mutex_lock(3)">https://man.cx/pthread_mutex_lock(3)</a> </dd></dl>

</div>
</div>
<a id="ga8bd074884e1c92e88ca8ea0552d9a928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bd074884e1c92e88ca8ea0552d9a928">&#9670;&nbsp;</a></span>mutex_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mutex_trylock </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>pmtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_mutex_trylock</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>pmtx != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_mutex_trylock </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_mutex_trylock(3)">https://man.cx/pthread_mutex_trylock(3)</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true (<code>!=0</code>) if lock succeeds, false (<code>0</code>) otherwise </dd></dl>

</div>
</div>
<a id="ga95235231165ebda870afa10ba5fd6c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95235231165ebda870afa10ba5fd6c41">&#9670;&nbsp;</a></span>mutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>pmtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_mutex_unlock</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>pmtx != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_mutex_unlock </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_mutex_unlock(3)">https://man.cx/pthread_mutex_unlock(3)</a> </dd></dl>

</div>
</div>
<a id="ga31e5eaf158d118d0e4ef7fd47368eaad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31e5eaf158d118d0e4ef7fd47368eaad">&#9670;&nbsp;</a></span>cond_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cond_init </td>
          <td>(</td>
          <td class="paramtype">pthread_cond_t *&#160;</td>
          <td class="paramname"><em>pcvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_condattr_t *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_cond_init</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>pcvar != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_cond_init </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_cond_init(3)">https://man.cx/pthread_cond_init(3)</a> </dd></dl>

</div>
</div>
<a id="gad663c43fbfbb4f660d48b07e110c8f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad663c43fbfbb4f660d48b07e110c8f80">&#9670;&nbsp;</a></span>cond_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cond_destroy </td>
          <td>(</td>
          <td class="paramtype">pthread_cond_t *&#160;</td>
          <td class="paramname"><em>pcvar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_cond_destroy</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>pcvar != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_cond_destroy </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_cond_destroy(3)">https://man.cx/pthread_cond_destroy(3)</a> </dd></dl>

</div>
</div>
<a id="ga1123643838d5174ccd41f52f4169e896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1123643838d5174ccd41f52f4169e896">&#9670;&nbsp;</a></span>cond_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cond_wait </td>
          <td>(</td>
          <td class="paramtype">pthread_cond_t *&#160;</td>
          <td class="paramname"><em>pcvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>pmtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_cond_wait</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>pcvar != NULL</code><br  />
 <code>pmtx != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_cond_wait </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_cond_wait(3)">https://man.cx/pthread_cond_wait(3)</a> </dd></dl>

</div>
</div>
<a id="ga8cd2040836c30e4f0ea17abe4f66b8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cd2040836c30e4f0ea17abe4f66b8e2">&#9670;&nbsp;</a></span>cond_timedwait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cond_timedwait </td>
          <td>(</td>
          <td class="paramtype">pthread_cond_t *&#160;</td>
          <td class="paramname"><em>pcvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>pmtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abstime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_cond_timedwait</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>pcvar != NULL</code><br  />
 <code>pmtx != NULL</code><br  />
 <code>abstime != NULL</code> </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (<code>!=0</code>) if condition variable was signaled, false (<code>0</code>) it time out has expired.</dd></dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_cond_timedwait </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_cond_wait(3)">https://man.cx/pthread_cond_wait(3)</a> </dd></dl>

</div>
</div>
<a id="ga4b41089ba3cd8ad0a539b42bc8b95d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b41089ba3cd8ad0a539b42bc8b95d6b">&#9670;&nbsp;</a></span>cond_timedwait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cond_timedwait </td>
          <td>(</td>
          <td class="paramtype">pthread_cond_t *&#160;</td>
          <td class="paramname"><em>pcvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>pmtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>relative_time_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_cond_timedwait</code> wrapper function accepting relative time (in microseconds) instead of absolute time. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>pcvar != NULL</code><br  />
 <code>pmtx != NULL</code><br  />
 <code>relative_time_us &gt; 0L</code> </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (<code>!=0</code>) if condition variable was signaled, false (<code>0</code>) it time out has expired.</dd></dl>
<p>Documentation in</p><pre class="fragment">man 3 pthread_cond_timedwait </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_cond_wait(3)">https://man.cx/pthread_cond_wait(3)</a> </dd></dl>

</div>
</div>
<a id="ga9624688b577fb653af7a528848cc53d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9624688b577fb653af7a528848cc53d5">&#9670;&nbsp;</a></span>cond_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cond_signal </td>
          <td>(</td>
          <td class="paramtype">pthread_cond_t *&#160;</td>
          <td class="paramname"><em>pcvar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_cond_signal</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>pcvar != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_cond_signal </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_cond_signal(3)">https://man.cx/pthread_cond_signal(3)</a> </dd></dl>

</div>
</div>
<a id="ga6459039ab27da7237dda2bbc866eb2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6459039ab27da7237dda2bbc866eb2d0">&#9670;&nbsp;</a></span>cond_broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cond_broadcast </td>
          <td>(</td>
          <td class="paramtype">pthread_cond_t *&#160;</td>
          <td class="paramname"><em>pcvar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_cond_broadcast</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>pcvar != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_cond_broadcast </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_cond_broadcast(3)">https://man.cx/pthread_cond_broadcast(3)</a> </dd></dl>

</div>
</div>
<a id="gad0428e8a0809704f4b3d682f26d3ef1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0428e8a0809704f4b3d682f26d3ef1c">&#9670;&nbsp;</a></span>thread_once()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_once </td>
          <td>(</td>
          <td class="paramtype">pthread_once_t *&#160;</td>
          <td class="paramname"><em>once_control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>init_routine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_once</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>once_control != NULL</code><br  />
 <code>init_routine != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_once </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_once(3)">https://man.cx/pthread_once(3)</a> </dd></dl>

</div>
</div>
<a id="ga7df1983f57dca40a86a55d215d13d42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7df1983f57dca40a86a55d215d13d42b">&#9670;&nbsp;</a></span>thread_key_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_key_create </td>
          <td>(</td>
          <td class="paramtype">pthread_key_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>destr_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_key_create</code> wrapper function. </p>
<p>This function should be executed once for each key (use <a class="el" href="group__thread.html#gad0428e8a0809704f4b3d682f26d3ef1c" title="pthread_once wrapper function.">thread_once()</a>).</p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>key != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_key_create </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_key_create(3)">https://man.cx/pthread_key_create(3)</a> </dd></dl>

</div>
</div>
<a id="ga65a50dfc97c087a28cb916e0f30f760e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65a50dfc97c087a28cb916e0f30f760e">&#9670;&nbsp;</a></span>thread_key_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_key_delete </td>
          <td>(</td>
          <td class="paramtype">pthread_key_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_key_delete</code> wrapper function. </p>
<p>This function should be executed once for each key (use <a class="el" href="group__thread.html#gad0428e8a0809704f4b3d682f26d3ef1c" title="pthread_once wrapper function.">thread_once()</a>).</p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>key != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_key_delete </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_key_delete(3)">https://man.cx/pthread_key_delete(3)</a> </dd></dl>

</div>
</div>
<a id="ga3008b033f2830e79179a882a2b74c8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3008b033f2830e79179a882a2b74c8ba">&#9670;&nbsp;</a></span>thread_setspecific()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_setspecific </td>
          <td>(</td>
          <td class="paramtype">pthread_key_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_setspecific</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>pointer != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_setspecific </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_setspecific(3)">https://man.cx/pthread_setspecific(3)</a> </dd></dl>

</div>
</div>
<a id="ga0d207f1bb2e1d493b68a026b8650cb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d207f1bb2e1d493b68a026b8650cb16">&#9670;&nbsp;</a></span>thread_getspecific()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* thread_getspecific </td>
          <td>(</td>
          <td class="paramtype">pthread_key_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_getspecific</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>key != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_getspecific </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_getspecific(3)">https://man.cx/pthread_getspecific(3)</a> </dd></dl>

</div>
</div>
<a id="ga9fb2733a01e8d668a2022005ea5dbebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fb2733a01e8d668a2022005ea5dbebd">&#9670;&nbsp;</a></span>mutexattr_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutexattr_init </td>
          <td>(</td>
          <td class="paramtype">pthread_mutexattr_t *&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_mutexattr_init</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>attr != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_mutexattr_init </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_mutexattr_init(3)">https://man.cx/pthread_mutexattr_init(3)</a> </dd></dl>

</div>
</div>
<a id="ga07bf0e49b1f2cb99d3a2955641c676d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07bf0e49b1f2cb99d3a2955641c676d5">&#9670;&nbsp;</a></span>mutexattr_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutexattr_destroy </td>
          <td>(</td>
          <td class="paramtype">pthread_mutexattr_t *&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_mutexattr_destroy</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>attr != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_mutexattr_destroy </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_mutexattr_destroy(3)">https://man.cx/pthread_mutexattr_destroy(3)</a> </dd></dl>

</div>
</div>
<a id="ga601a6a9527d7d5ee2ca2870cddc4afc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga601a6a9527d7d5ee2ca2870cddc4afc2">&#9670;&nbsp;</a></span>mutexattr_settype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutexattr_settype </td>
          <td>(</td>
          <td class="paramtype">pthread_mutexattr_t *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_mutexattr_settype</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>attr != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_mutexattr_settype </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_mutexattr_settype(3)">https://man.cx/pthread_mutexattr_settype(3)</a> </dd></dl>

</div>
</div>
<a id="gadf741e1818d53c5b7d71cd68e161b215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf741e1818d53c5b7d71cd68e161b215">&#9670;&nbsp;</a></span>mutexattr_gettype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutexattr_gettype </td>
          <td>(</td>
          <td class="paramtype">const pthread_mutexattr_t *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_mutexattr_gettype</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>attr != NULL</code><br  />
 <code>kind != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_mutexattr_gettype </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_mutexattr_gettype(3)">https://man.cx/pthread_mutexattr_gettype(3)</a> </dd></dl>

</div>
</div>
<a id="gab8073c72be896ba9d711d887a5405a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8073c72be896ba9d711d887a5405a74">&#9670;&nbsp;</a></span>condattr_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void condattr_init </td>
          <td>(</td>
          <td class="paramtype">pthread_condattr_t *&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_condattr_init</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>attr != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_condattr_init </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_condattr_init(3)">https://man.cx/pthread_condattr_init(3)</a> </dd></dl>

</div>
</div>
<a id="ga4644f4989b30ccfb2e908017c43bd0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4644f4989b30ccfb2e908017c43bd0d0">&#9670;&nbsp;</a></span>condattr_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void condattr_destroy </td>
          <td>(</td>
          <td class="paramtype">pthread_condattr_t *&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_condattr_destroy</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>attr != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_condattr_destroy </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_condattr_destroy(3)">https://man.cx/pthread_condattr_destroy(3)</a> </dd></dl>

</div>
</div>
<a id="gaaf2db7012069f0006e7ffaf257d8ccc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf2db7012069f0006e7ffaf257d8ccc6">&#9670;&nbsp;</a></span>thread_attr_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_attr_init </td>
          <td>(</td>
          <td class="paramtype">pthread_attr_t *&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_attr_init</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>attr != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_attr_init </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_attr_init(3)">https://man.cx/pthread_attr_init(3)</a> </dd></dl>

</div>
</div>
<a id="gaf3a9c2c051deee01e21c75f0fa8b2e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3a9c2c051deee01e21c75f0fa8b2e9c">&#9670;&nbsp;</a></span>thread_attr_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_attr_destroy </td>
          <td>(</td>
          <td class="paramtype">pthread_attr_t *&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_attr_destroy</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>attr != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_attr_destroy </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_attr_destroy(3)">https://man.cx/pthread_attr_destroy(3)</a> </dd></dl>

</div>
</div>
<a id="gabc82fea1785fc82aeb2f43cdd77b9b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc82fea1785fc82aeb2f43cdd77b9b0f">&#9670;&nbsp;</a></span>thread_attr_setdetachstate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_attr_setdetachstate </td>
          <td>(</td>
          <td class="paramtype">pthread_attr_t *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>detachstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_attr_setdetachstate</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>attr != NULL</code><br  />
 <code>detachstate == PTHREAD_CREATE_DETACHED || detachstate == PTHREAD_CREATE_JOINABLE</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_attr_setdetachstate </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_attr_setdetachstate(3)">https://man.cx/pthread_attr_setdetachstate(3)</a> </dd></dl>

</div>
</div>
<a id="gaae83c8617612c1bb481fec2b382ac9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae83c8617612c1bb481fec2b382ac9c4">&#9670;&nbsp;</a></span>thread_attr_getdetachstate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_attr_getdetachstate </td>
          <td>(</td>
          <td class="paramtype">const pthread_attr_t *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pdetachstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_attr_getdetachstate</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>attr != NULL</code><br  />
 <code>pdetachstate != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_attr_getdetachstate </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_attr_getdetachstate(3)">https://man.cx/pthread_attr_getdetachstate(3)</a> </dd></dl>

</div>
</div>
<a id="ga1b3cb53565eabe02a36e000e5244dfd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b3cb53565eabe02a36e000e5244dfd1">&#9670;&nbsp;</a></span>thread_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_cancel </td>
          <td>(</td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_cancel</code> wrapper function. </p>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_cancel </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_cancel(3)">https://man.cx/pthread_cancel(3)</a> </dd></dl>

</div>
</div>
<a id="ga98baffe08beec792f3428ae9ddad966e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98baffe08beec792f3428ae9ddad966e">&#9670;&nbsp;</a></span>thread_setcancelstate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_setcancelstate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>oldstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_setcancelstate</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>state == PTHREAD_CANCEL_ENABLE || state == PTHREAD_CANCEL_DISABLE</code><br  />
 <code>oldstate != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_setcancelstate </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_setcancelstate(3)">https://man.cx/pthread_setcancelstate(3)</a> </dd></dl>

</div>
</div>
<a id="gab4ec114c7b59f8f4185bac648b256d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4ec114c7b59f8f4185bac648b256d0c">&#9670;&nbsp;</a></span>thread_setcanceltype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_setcanceltype </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>oldtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_setcanceltype</code> wrapper function. </p>
<dl>
<dt><b>Precondition:</b> </dt>
<dd><code>type == PTHREAD_CANCEL_DEFERRED || type == PTHREAD_CANCEL_ASYNCHRONOUS</code><br  />
 <code>oldtype != NULL</code> </dd>
</dl>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_setcanceltype </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_setcanceltype(3)">https://man.cx/pthread_setcanceltype(3)</a> </dd></dl>

</div>
</div>
<a id="ga81bdb13d62e16ad7cb3cbd263c9a5671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81bdb13d62e16ad7cb3cbd263c9a5671">&#9670;&nbsp;</a></span>thread_testcancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_testcancel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pthread_testcancel</code> wrapper function. </p>
<p>Other documentation in</p><pre class="fragment">man 3 pthread_testcancel </pre><dl class="section see"><dt>See also</dt><dd><a href="https://man.cx/pthread_testcancel(3)">https://man.cx/pthread_testcancel(3)</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
